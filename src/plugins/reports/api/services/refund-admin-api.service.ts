import { Administrator, ChannelService, Refund, RequestContext, TransactionalConnection,UserService } from '@etech/core';
import { RefundReport, RefundReportContent, RefundReportFilter } from '../../ui/generated-admin-types';
import {Injectable} from '@nestjs/common';
import { default as dayjs } from 'dayjs';
@Injectable()
export class RefundReportService{
    constructor(private connection: TransactionalConnection, 
      private channelService: ChannelService,
      private userService: UserService,){
    }

    async getRefundReport(ctx: RequestContext, filter: RefundReportFilter): Promise<RefundReport>{
      let userAdmin= await this.userService.getUserById(ctx, ctx.activeUserId);
      let header:string=''; 
      let refunds= this.connection.getRepository(ctx, Refund)
        .createQueryBuilder("refund")
        .innerJoinAndSelect("refund.orderItems", "orderItems")
        .innerJoinAndSelect("refund.payment", "payment")
        .innerJoinAndSelect("payment.order", "order");
        if(filter.purchased){
            if(filter.purchased.before){
                refunds= refunds.andWhere(
                    `order.orderPlacedAt
                  < :end`,
                    {
                      // begin: new Date(0,0,0).toISOString(),
                      end: filter.purchased.before,
                    }
                  )
                  header+=`, involving orders placed before ${dayjs(filter.purchased.before).format('ddd, MMM D, YYYY h:mm A ')}`
            }else if(filter.purchased.after){
                refunds= refunds.andWhere(
                    `order.orderPlacedAt
                  >= :begin
                    `,
                    {
                      begin: filter.purchased.after,
                      // end: new Date().toISOString(),
                    }
                  )
                  header+=`, involving orders placed after ${dayjs(filter.purchased.after).format('ddd, MMM D, YYYY h:mm A ')}`
            }else if(filter.purchased.between){
                refunds= refunds.andWhere(
                    `order.orderPlacedAt
                  >= :begin
                     AND order.orderPlacedAt <= :end`,
                    {
                      begin: filter.purchased.between.start,
                      end: filter.purchased.between.end,
                    }
                  )
                  header+=`, involving orders placed between ${dayjs(filter.purchased.between.start).format('ddd, MMM D, YYYY h:mm A ')} and 
                  ${dayjs(filter.purchased.between.end).format('ddd, MMM D, YYYY h:mm A ')}`
            }else{
              //no condition, suppose to be empty object
              if(Object.keys(filter.purchased).length !== 0){
                console.log('Unexpected purchased');
              }
            }
        }
        if(filter.amount){
          header+=`, with an amount of ${filter.amount} ETB`
          refunds= refunds.andWhere(`refund.total=${Math.floor(filter.amount*100)}`)
        }
        refunds= refunds.andWhere('refund.state="Settled"')
        let selectedRefunds= await refunds.getMany();
        let reportContent:RefundReportContent[]=[];
        const adminRepository= this.connection.getRepository(ctx, Administrator);
        for(let refund of selectedRefunds){
            let admin= await adminRepository.createQueryBuilder('admin')
            .select(["admin.firstName", "admin.lastName", "admin.id"])
            .where(`FIND_IN_SET(${refund.id},customFieldsRefunds)`).getOne();
            reportContent.push({
                orderId: refund.payment.order.id,
                orderCode: refund.payment.order.code,
                refunded: refund.updatedAt.toDateString(),
                customer: refund.payment.order.customer ? 
                    refund.payment.order.customer.firstName + ' ' + refund.payment.order.customer.lastName: "Guest",
                customerId: refund.payment.order.customer ? refund.payment.order.customer.id:-1,
                paymentMethod: refund.payment.method,
                refundedAmount: `${refund.total/100} ETB`,
                purchaseDate: refund.payment.order.createdAt.toDateString(),
                price: `${refund.payment.order.total/100} ETB`,
                refundType: refund.reason,
                refundedBy: admin?admin.firstName+' '+admin.lastName:"",
                refundedById: admin?admin.id:-1,
            });
            // }
        }
        // header+=".";
        return {content: reportContent, header: `This report, generated by ${userAdmin.identifier}, 
        contains ${reportContent.length} refunds`+header,};
    }
}